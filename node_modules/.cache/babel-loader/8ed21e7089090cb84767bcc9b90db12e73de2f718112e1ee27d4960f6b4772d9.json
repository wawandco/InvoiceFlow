{"ast":null,"code":"import { HttpClient, HttpClientResponse } from './HttpClient.js';\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nexport class FetchHttpClient extends HttpClient {\n  constructor(fetchFn) {\n    super();\n    // Default to global fetch if available\n    if (!fetchFn) {\n      if (!globalThis.fetch) {\n        throw new Error('fetch() function not provided and is not defined in the global scope. ' + 'You must provide a fetch implementation.');\n      }\n      fetchFn = globalThis.fetch;\n    }\n    // Both timeout behaviors differs from Node:\n    // - Fetch uses a single timeout for the entire length of the request.\n    // - Node is more fine-grained and resets the timeout after each stage of the request.\n    if (globalThis.AbortController) {\n      // Utilise native AbortController if available\n      // AbortController was added in Node v15.0.0, v14.17.0\n      this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);\n    } else {\n      // Fall back to racing against a timeout promise if not available in the runtime\n      // This does not actually cancel the underlying fetch operation or resources\n      this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);\n    }\n  }\n  static makeFetchWithRaceTimeout(fetchFn) {\n    return (url, init, timeout) => {\n      let pendingTimeoutId;\n      const timeoutPromise = new Promise((_, reject) => {\n        pendingTimeoutId = setTimeout(() => {\n          pendingTimeoutId = null;\n          reject(HttpClient.makeTimeoutError());\n        }, timeout);\n      });\n      const fetchPromise = fetchFn(url, init);\n      return Promise.race([fetchPromise, timeoutPromise]).finally(() => {\n        if (pendingTimeoutId) {\n          clearTimeout(pendingTimeoutId);\n        }\n      });\n    };\n  }\n  static makeFetchWithAbortTimeout(fetchFn) {\n    return async (url, init, timeout) => {\n      // Use AbortController because AbortSignal.timeout() was added later in Node v17.3.0, v16.14.0\n      const abort = new AbortController();\n      let timeoutId = setTimeout(() => {\n        timeoutId = null;\n        abort.abort(HttpClient.makeTimeoutError());\n      }, timeout);\n      try {\n        return await fetchFn(url, Object.assign(Object.assign({}, init), {\n          signal: abort.signal\n        }));\n      } catch (err) {\n        // Some implementations, like node-fetch, do not respect the reason passed to AbortController.abort()\n        // and instead it always throws an AbortError\n        // We catch this case to normalise all timeout errors\n        if (err.name === 'AbortError') {\n          throw HttpClient.makeTimeoutError();\n        } else {\n          throw err;\n        }\n      } finally {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n    };\n  }\n  /** @override. */\n  getClientName() {\n    return 'fetch';\n  }\n  async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n    const isInsecureConnection = protocol === 'http';\n    const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n    url.port = port;\n    // For methods which expect payloads, we should always pass a body value\n    // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n    // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n    // for more details.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    const body = requestData || (methodHasPayload ? '' : undefined);\n    const res = await this._fetchFn(url.toString(), {\n      method,\n      // @ts-ignore\n      headers,\n      // @ts-ignore\n      body\n    }, timeout);\n    return new FetchHttpClientResponse(res);\n  }\n}\nexport class FetchHttpClientResponse extends HttpClientResponse {\n  constructor(res) {\n    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n    this._res = res;\n  }\n  getRawResponse() {\n    return this._res;\n  }\n  toStream(streamCompleteCallback) {\n    // Unfortunately `fetch` does not have event handlers for when the stream is\n    // completely read. We therefore invoke the streamCompleteCallback right\n    // away. This callback emits a response event with metadata and completes\n    // metrics, so it's ok to do this without waiting for the stream to be\n    // completely read.\n    streamCompleteCallback();\n    // Fetch's `body` property is expected to be a readable stream of the body.\n    return this._res.body;\n  }\n  toJSON() {\n    return this._res.json();\n  }\n  static _transformHeadersToObject(headers) {\n    // Fetch uses a Headers instance so this must be converted to a barebones\n    // JS object to meet the HttpClient interface.\n    const headersObj = {};\n    for (const entry of headers) {\n      if (!Array.isArray(entry) || entry.length != 2) {\n        throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n      }\n      headersObj[entry[0]] = entry[1];\n    }\n    return headersObj;\n  }\n}","map":{"version":3,"names":["HttpClient","HttpClientResponse","FetchHttpClient","constructor","fetchFn","globalThis","fetch","Error","AbortController","_fetchFn","makeFetchWithAbortTimeout","makeFetchWithRaceTimeout","url","init","timeout","pendingTimeoutId","timeoutPromise","Promise","_","reject","setTimeout","makeTimeoutError","fetchPromise","race","finally","clearTimeout","abort","timeoutId","Object","assign","signal","err","name","getClientName","makeRequest","host","port","path","method","headers","requestData","protocol","isInsecureConnection","URL","methodHasPayload","body","undefined","res","toString","FetchHttpClientResponse","status","_transformHeadersToObject","_res","getRawResponse","toStream","streamCompleteCallback","toJSON","json","headersObj","entry","Array","isArray","length"],"sources":["/Users/manuelperez/Projects/React/InvoiceFlow/node_modules/stripe/esm/net/FetchHttpClient.js"],"sourcesContent":["import { HttpClient, HttpClientResponse, } from './HttpClient.js';\n/**\n * HTTP client which uses a `fetch` function to issue requests.\n *\n * By default relies on the global `fetch` function, but an optional function\n * can be passed in. If passing in a function, it is expected to match the Web\n * Fetch API. As an example, this could be the function provided by the\n * node-fetch package (https://github.com/node-fetch/node-fetch).\n */\nexport class FetchHttpClient extends HttpClient {\n    constructor(fetchFn) {\n        super();\n        // Default to global fetch if available\n        if (!fetchFn) {\n            if (!globalThis.fetch) {\n                throw new Error('fetch() function not provided and is not defined in the global scope. ' +\n                    'You must provide a fetch implementation.');\n            }\n            fetchFn = globalThis.fetch;\n        }\n        // Both timeout behaviors differs from Node:\n        // - Fetch uses a single timeout for the entire length of the request.\n        // - Node is more fine-grained and resets the timeout after each stage of the request.\n        if (globalThis.AbortController) {\n            // Utilise native AbortController if available\n            // AbortController was added in Node v15.0.0, v14.17.0\n            this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);\n        }\n        else {\n            // Fall back to racing against a timeout promise if not available in the runtime\n            // This does not actually cancel the underlying fetch operation or resources\n            this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);\n        }\n    }\n    static makeFetchWithRaceTimeout(fetchFn) {\n        return (url, init, timeout) => {\n            let pendingTimeoutId;\n            const timeoutPromise = new Promise((_, reject) => {\n                pendingTimeoutId = setTimeout(() => {\n                    pendingTimeoutId = null;\n                    reject(HttpClient.makeTimeoutError());\n                }, timeout);\n            });\n            const fetchPromise = fetchFn(url, init);\n            return Promise.race([fetchPromise, timeoutPromise]).finally(() => {\n                if (pendingTimeoutId) {\n                    clearTimeout(pendingTimeoutId);\n                }\n            });\n        };\n    }\n    static makeFetchWithAbortTimeout(fetchFn) {\n        return async (url, init, timeout) => {\n            // Use AbortController because AbortSignal.timeout() was added later in Node v17.3.0, v16.14.0\n            const abort = new AbortController();\n            let timeoutId = setTimeout(() => {\n                timeoutId = null;\n                abort.abort(HttpClient.makeTimeoutError());\n            }, timeout);\n            try {\n                return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));\n            }\n            catch (err) {\n                // Some implementations, like node-fetch, do not respect the reason passed to AbortController.abort()\n                // and instead it always throws an AbortError\n                // We catch this case to normalise all timeout errors\n                if (err.name === 'AbortError') {\n                    throw HttpClient.makeTimeoutError();\n                }\n                else {\n                    throw err;\n                }\n            }\n            finally {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n            }\n        };\n    }\n    /** @override. */\n    getClientName() {\n        return 'fetch';\n    }\n    async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {\n        const isInsecureConnection = protocol === 'http';\n        const url = new URL(path, `${isInsecureConnection ? 'http' : 'https'}://${host}`);\n        url.port = port;\n        // For methods which expect payloads, we should always pass a body value\n        // even when it is empty. Without this, some JS runtimes (eg. Deno) will\n        // inject a second Content-Length header. See https://github.com/stripe/stripe-node/issues/1519\n        // for more details.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        const body = requestData || (methodHasPayload ? '' : undefined);\n        const res = await this._fetchFn(url.toString(), {\n            method,\n            // @ts-ignore\n            headers,\n            // @ts-ignore\n            body,\n        }, timeout);\n        return new FetchHttpClientResponse(res);\n    }\n}\nexport class FetchHttpClientResponse extends HttpClientResponse {\n    constructor(res) {\n        super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));\n        this._res = res;\n    }\n    getRawResponse() {\n        return this._res;\n    }\n    toStream(streamCompleteCallback) {\n        // Unfortunately `fetch` does not have event handlers for when the stream is\n        // completely read. We therefore invoke the streamCompleteCallback right\n        // away. This callback emits a response event with metadata and completes\n        // metrics, so it's ok to do this without waiting for the stream to be\n        // completely read.\n        streamCompleteCallback();\n        // Fetch's `body` property is expected to be a readable stream of the body.\n        return this._res.body;\n    }\n    toJSON() {\n        return this._res.json();\n    }\n    static _transformHeadersToObject(headers) {\n        // Fetch uses a Headers instance so this must be converted to a barebones\n        // JS object to meet the HttpClient interface.\n        const headersObj = {};\n        for (const entry of headers) {\n            if (!Array.isArray(entry) || entry.length != 2) {\n                throw new Error('Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.');\n            }\n            headersObj[entry[0]] = entry[1];\n        }\n        return headersObj;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}