{"ast":null,"code":"import { callbackifyPromiseWithTimeout, getDataFromArgs } from './utils.js';\nclass StripeIterator {\n  constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n    this.index = 0;\n    this.pagePromise = firstPagePromise;\n    this.promiseCache = {\n      currentPromise: null\n    };\n    this.requestArgs = requestArgs;\n    this.spec = spec;\n    this.stripeResource = stripeResource;\n  }\n  async iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    if (this.index < pageResult.data.length) {\n      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;\n      const value = pageResult.data[idx];\n      this.index += 1;\n      return {\n        value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      this.index = 0;\n      this.pagePromise = this.getNextPage(pageResult);\n      const nextPageResult = await this.pagePromise;\n      return this.iterate(nextPageResult);\n    }\n    return {\n      done: true,\n      value: undefined\n    };\n  }\n  /** @abstract */\n  getNextPage(_pageResult) {\n    throw new Error('Unimplemented');\n  }\n  async _next() {\n    return this.iterate(await this.pagePromise);\n  }\n  next() {\n    /**\n     * If a user calls `.next()` multiple times in parallel,\n     * return the same result until something has resolved\n     * to prevent page-turning race conditions.\n     */\n    if (this.promiseCache.currentPromise) {\n      return this.promiseCache.currentPromise;\n    }\n    const nextPromise = (async () => {\n      const ret = await this._next();\n      this.promiseCache.currentPromise = null;\n      return ret;\n    })();\n    this.promiseCache.currentPromise = nextPromise;\n    return nextPromise;\n  }\n}\nclass ListIterator extends StripeIterator {\n  getNextPage(pageResult) {\n    const reverseIteration = isReverseIteration(this.requestArgs);\n    const lastId = getLastId(pageResult, reverseIteration);\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      [reverseIteration ? 'ending_before' : 'starting_after']: lastId\n    });\n  }\n}\nclass SearchIterator extends StripeIterator {\n  getNextPage(pageResult) {\n    if (!pageResult.next_page) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n    }\n    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n      page: pageResult.next_page\n    });\n  }\n}\nexport const makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n  if (spec.methodType === 'search') {\n    return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  if (spec.methodType === 'list') {\n    return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n  }\n  return null;\n};\nconst makeAutoPaginationMethodsFromIterator = iterator => {\n  const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n  const autoPaginationMethods = {\n    autoPagingEach,\n    autoPagingToArray,\n    // Async iterator functions:\n    next: () => iterator.next(),\n    return: () => {\n      // This is required for `break`.\n      return {};\n    },\n    [getAsyncIteratorSymbol()]: () => {\n      return autoPaginationMethods;\n    }\n  };\n  return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  }\n  // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n  return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return null;\n  }\n  const onDone = args[1];\n  if (typeof onDone !== 'function') {\n    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n  }\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n  const onItem = args[0];\n  if (typeof onItem !== 'function') {\n    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n  }\n  // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n  if (onItem.length === 2) {\n    return onItem;\n  }\n  if (onItem.length > 2) {\n    throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n  }\n  // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n  return function _onItem(item, next) {\n    const shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\nfunction getLastId(listResult, reverseIteration) {\n  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  const lastItem = listResult.data[lastIdx];\n  const lastId = lastItem && lastItem.id;\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n  return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function autoPagingEach( /* onItem?, onDone? */\n  ) {\n    const args = [].slice.call(arguments);\n    const onItem = getItemCallback(args);\n    const onDone = getDoneCallback(args);\n    if (args.length > 2) {\n      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n    }\n    const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext,\n    // @ts-ignore we might need a null check\n    onItem);\n    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    const limit = opts && opts.limit;\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n    const promise = new Promise((resolve, reject) => {\n      const items = [];\n      autoPagingEach(item => {\n        items.push(item);\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(() => {\n        resolve(items);\n      }).catch(reject);\n    });\n    // @ts-ignore\n    return callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise((resolve, reject) => {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n      const item = iterResult.value;\n      return new Promise(next => {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(shouldContinue => {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true,\n            value: undefined\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\nfunction isReverseIteration(requestArgs) {\n  const args = [].slice.call(requestArgs);\n  const dataFromArgs = getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}","map":{"version":3,"names":["callbackifyPromiseWithTimeout","getDataFromArgs","StripeIterator","constructor","firstPagePromise","requestArgs","spec","stripeResource","index","pagePromise","promiseCache","currentPromise","iterate","pageResult","data","length","Error","reverseIteration","isReverseIteration","idx","value","done","has_more","getNextPage","nextPageResult","undefined","_pageResult","_next","next","nextPromise","ret","ListIterator","lastId","getLastId","_makeRequest","SearchIterator","next_page","page","makeAutoPaginationMethods","methodType","makeAutoPaginationMethodsFromIterator","iterator","autoPagingEach","makeAutoPagingEach","args","autoPagingToArray","makeAutoPagingToArray","autoPaginationMethods","return","getAsyncIteratorSymbol","Symbol","asyncIterator","getDoneCallback","onDone","getItemCallback","onItem","_onItem","item","shouldContinue","listResult","lastIdx","lastItem","id","asyncIteratorNext","slice","call","arguments","autoPagePromise","wrapAsyncIteratorWithCallback","opts","limit","promise","Promise","resolve","reject","items","push","then","catch","handleIteration","iterResult","dataFromArgs","ending_before"],"sources":["/Users/manuelperez/Projects/React/InvoiceFlow/node_modules/stripe/esm/autoPagination.js"],"sourcesContent":["import { callbackifyPromiseWithTimeout, getDataFromArgs } from './utils.js';\nclass StripeIterator {\n    constructor(firstPagePromise, requestArgs, spec, stripeResource) {\n        this.index = 0;\n        this.pagePromise = firstPagePromise;\n        this.promiseCache = { currentPromise: null };\n        this.requestArgs = requestArgs;\n        this.spec = spec;\n        this.stripeResource = stripeResource;\n    }\n    async iterate(pageResult) {\n        if (!(pageResult &&\n            pageResult.data &&\n            typeof pageResult.data.length === 'number')) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n        }\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        if (this.index < pageResult.data.length) {\n            const idx = reverseIteration\n                ? pageResult.data.length - 1 - this.index\n                : this.index;\n            const value = pageResult.data[idx];\n            this.index += 1;\n            return { value, done: false };\n        }\n        else if (pageResult.has_more) {\n            // Reset counter, request next page, and recurse.\n            this.index = 0;\n            this.pagePromise = this.getNextPage(pageResult);\n            const nextPageResult = await this.pagePromise;\n            return this.iterate(nextPageResult);\n        }\n        return { done: true, value: undefined };\n    }\n    /** @abstract */\n    getNextPage(_pageResult) {\n        throw new Error('Unimplemented');\n    }\n    async _next() {\n        return this.iterate(await this.pagePromise);\n    }\n    next() {\n        /**\n         * If a user calls `.next()` multiple times in parallel,\n         * return the same result until something has resolved\n         * to prevent page-turning race conditions.\n         */\n        if (this.promiseCache.currentPromise) {\n            return this.promiseCache.currentPromise;\n        }\n        const nextPromise = (async () => {\n            const ret = await this._next();\n            this.promiseCache.currentPromise = null;\n            return ret;\n        })();\n        this.promiseCache.currentPromise = nextPromise;\n        return nextPromise;\n    }\n}\nclass ListIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        const reverseIteration = isReverseIteration(this.requestArgs);\n        const lastId = getLastId(pageResult, reverseIteration);\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            [reverseIteration ? 'ending_before' : 'starting_after']: lastId,\n        });\n    }\n}\nclass SearchIterator extends StripeIterator {\n    getNextPage(pageResult) {\n        if (!pageResult.next_page) {\n            throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n        }\n        return this.stripeResource._makeRequest(this.requestArgs, this.spec, {\n            page: pageResult.next_page,\n        });\n    }\n}\nexport const makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {\n    if (spec.methodType === 'search') {\n        return makeAutoPaginationMethodsFromIterator(new SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    if (spec.methodType === 'list') {\n        return makeAutoPaginationMethodsFromIterator(new ListIterator(firstPagePromise, requestArgs, spec, stripeResource));\n    }\n    return null;\n};\nconst makeAutoPaginationMethodsFromIterator = (iterator) => {\n    const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));\n    const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n    const autoPaginationMethods = {\n        autoPagingEach,\n        autoPagingToArray,\n        // Async iterator functions:\n        next: () => iterator.next(),\n        return: () => {\n            // This is required for `break`.\n            return {};\n        },\n        [getAsyncIteratorSymbol()]: () => {\n            return autoPaginationMethods;\n        },\n    };\n    return autoPaginationMethods;\n};\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\nfunction getAsyncIteratorSymbol() {\n    if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n        return Symbol.asyncIterator;\n    }\n    // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n    return '@@asyncIterator';\n}\nfunction getDoneCallback(args) {\n    if (args.length < 2) {\n        return null;\n    }\n    const onDone = args[1];\n    if (typeof onDone !== 'function') {\n        throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);\n    }\n    return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\nfunction getItemCallback(args) {\n    if (args.length === 0) {\n        return undefined;\n    }\n    const onItem = args[0];\n    if (typeof onItem !== 'function') {\n        throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);\n    }\n    // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n    if (onItem.length === 2) {\n        return onItem;\n    }\n    if (onItem.length > 2) {\n        throw Error(`The \\`onItem\\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);\n    }\n    // This magically handles all three of these usecases (the latter two being functionally identical):\n    // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n    // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n    // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n    return function _onItem(item, next) {\n        const shouldContinue = onItem(item);\n        next(shouldContinue);\n    };\n}\nfunction getLastId(listResult, reverseIteration) {\n    const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n    const lastItem = listResult.data[lastIdx];\n    const lastId = lastItem && lastItem.id;\n    if (!lastId) {\n        throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n    }\n    return lastId;\n}\nfunction makeAutoPagingEach(asyncIteratorNext) {\n    return function autoPagingEach( /* onItem?, onDone? */) {\n        const args = [].slice.call(arguments);\n        const onItem = getItemCallback(args);\n        const onDone = getDoneCallback(args);\n        if (args.length > 2) {\n            throw Error(`autoPagingEach takes up to two arguments; received ${args}`);\n        }\n        const autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, \n        // @ts-ignore we might need a null check\n        onItem);\n        return callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n    };\n}\nfunction makeAutoPagingToArray(autoPagingEach) {\n    return function autoPagingToArray(opts, onDone) {\n        const limit = opts && opts.limit;\n        if (!limit) {\n            throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n        }\n        if (limit > 10000) {\n            throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n        }\n        const promise = new Promise((resolve, reject) => {\n            const items = [];\n            autoPagingEach((item) => {\n                items.push(item);\n                if (items.length >= limit) {\n                    return false;\n                }\n            })\n                .then(() => {\n                resolve(items);\n            })\n                .catch(reject);\n        });\n        // @ts-ignore\n        return callbackifyPromiseWithTimeout(promise, onDone);\n    };\n}\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n    return new Promise((resolve, reject) => {\n        function handleIteration(iterResult) {\n            if (iterResult.done) {\n                resolve();\n                return;\n            }\n            const item = iterResult.value;\n            return new Promise((next) => {\n                // Bit confusing, perhaps; we pass a `resolve` fn\n                // to the user, so they can decide when and if to continue.\n                // They can return false, or a promise which resolves to false, to break.\n                onItem(item, next);\n            }).then((shouldContinue) => {\n                if (shouldContinue === false) {\n                    return handleIteration({ done: true, value: undefined });\n                }\n                else {\n                    return asyncIteratorNext().then(handleIteration);\n                }\n            });\n        }\n        asyncIteratorNext()\n            .then(handleIteration)\n            .catch(reject);\n    });\n}\nfunction isReverseIteration(requestArgs) {\n    const args = [].slice.call(requestArgs);\n    const dataFromArgs = getDataFromArgs(args);\n    return !!dataFromArgs.ending_before;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}